#! /usr/bin/env python3
#
#  This file is part of the python3 package "homeinfo.terminals"
#
#  (C) 2016: HOMEINFO - Digitale Informationssysteme GmbH
#
#  Maintainer: Richard Neumann <r dot neumann at homeinfo period de>
#
#####################################################################
"""Generates Nagios3 configurations
from HOMEINFO terminals monitoring

Usage:
    nagios-config.gen [--contacts] [--contactgroups] [--hosts] \
[--hostgroups] [--services] [--servicegroups]
"""

from os.path import join, basename
from logging import INFO, basicConfig, getLogger

from docopt import docopt

from homeinfo.lib.system import run, evaluate
from homeinfo.terminals.orm import VPNUnconfiguredError, Terminal, Class, \
    NagiosAdmin, NagiosService
from homeinfo.terminals.config import config


__all__ = [
    'ICONS',
    'SERVICES',
    'terminals',
    'mkcontacts',
    'mkcontactgroups',
    'mkhosts',
    'mkhostgroups',
    'mkservices',
    'mkservicegroups']

HEADER = '# Generated by {}\n# DO NOT EDIT THIS FILE MANUALLY!\n\n'

ICONS = {
    'Linux': 'logos/linux.gif',
    'NT': 'logos/windows.gif'}


class NagisService():
    """Nagios service data"""

    def __init__(self, name, description, symbol=None,
                 url=None, admins=None, admin_groups=None):
        """Sets service config data"""


SERVICES = {
    'statistics':
        ('Statistics evaluation', '../graph.gif', '#',
         {'ddb': ['ddb_admins']}),
    'synchronization':
        ('Synchronization status', '../logrotate.png', '#', None),
    'kernel':
        ('Kernel', 'logos/linux.gif', '#', None),
    'resolution':
        ('Display resolution', 'monitor.png', '#', None),
    'last-boot':
        ('Last boot', 'logos/turbolinux.gif', '#', None)}

logger = getLogger(basename(__file__))


def terminals():
    """Yields monitored terminals"""

    return Terminal.select().where(
            (Terminal.deleted >> None) & ~
            (Terminal.testing == 1) & ~
            (Terminal.deployed >> None))


def filter_svc(services, terminal):
    """Filters services for the provided terminal ORM"""

    # Services currently only apply tu Linux systems
    for service in services:
        if terminal.os.family == 'Linux':
            if service == 'resolution':
                if terminal.class_.name == 'ddb':
                    yield service
                else:
                    continue
            else:
                yield service


def header(generator=None):
    """Generates the file header"""

    return HEADER.format(__file__ if generator is None else generator)


def mkcontacts():
    """Generates contact configurations"""

    def render(template, admin):
        """Renders a Nagios administrator"""
        rendered = template.format(
            name=admin.name, alias=str(admin.employee),
            service_notification_period=str(admin.service_period),
            host_notification_period=str(admin.host_period),
            service_notification_options=str(admin.service_options),
            host_notification_options=str(admin.host_options),
            host_notification_commands=admin.host_command,
            email=str(admin.email))
        return rendered

    conf_path = join(
        config.monitoring['CONF_DIR'],
        config.monitoring['CONTACTS_FILE_NAME'])

    data = header()

    template = _template('nagios.contact.temp')

    for admin in NagiosAdmins:
        data += '{}\n\n'.format(render(template, admin))

    with open(conf_path, 'w') as cfg:
        cfg.write(data)


def mkcontactgroups():
    """Generates contact group configurations"""

    conf_path = join(
        config.monitoring['CONF_DIR'],
        config.monitoring['CONTACT_GROUPS_FILE_NAME'])

    template = _template('nagios.contactgroup.temp')

    data = header()

    admins = []

    for admin in NagiosAdmins.select().where(NagiosAdmins.class_ >> None):
        admins.append(admin.name)

    if admins:
        # Renders admins for all terminal classes
        rendered = template.format(
            name='admins',
            alias='Global terminal administrators',
            members=','.join(admins))
        data += '{}\n\n'.format(rendered)

    with open(conf_path, 'w') as cfg:
        cfg.write(data)


def mkhosts():
    """Generates host configurations"""

    def render(template, terminal):
        """Renders the template with the respective data"""
        icon = ICONS.get(terminal.os.family)
        location = terminal.location

        # Get terminal's location data
        if location is not None:
            notes = repr(location)
            street = location.address.street
            house_number = location.address.house_number
            zip_code = location.address.zip_code
            city = location.address.city
            annotation = location.annotation
        else:
            notes = 'Unknown'
            street = 'Unknown'
            house_number = 'Unknown'
            zip_code = 'Unknown'
            city = 'Unknown'
            annotation = None

        try:
            ipv4addr = terminal.ipv4addr
        except VPNUnconfiguredError:
            logger.error('Terminal {0} has no VPN configuration'.format(
                terminal))
        else:
            # Render and return
            return template.format(
                tid=str(terminal.tid), cid=str(terminal.cid),
                use=terminal.class_.name, host_name=terminal.hostname,
                alias=str(terminal), address=str(ipv4addr),
                notes=notes, street=street, house_number=house_number,
                zip_code=zip_code, city=city, icon=icon)

    conf_path = join(
        config.monitoring['CONF_DIR'],
        config.monitoring['HOSTS_FILE_NAME'])

    template = _template('nagios.host.temp')

    data = header()

    for terminal in terminals():
        data += '\n# {0}\n{1}\n'.format(terminal, render(template, terminal))

    with open(conf_path, 'w') as cfg:
        cfg.write(data)


def mkhostgroups():
    """Generates hostgroup configurations"""

    def render(template, name, full_name, memebers):
        """Renders host groups"""
        if members:
            rendered = template.format(
                name=name,
                alias=full_name,
                members=','.join(memebers))

            return rendered
        else:
            return ''

    conf_path = join(
        config.monitoring['CONF_DIR'],
        config.monitoring['GROUPS_FILE_NAME'])

    template = _template('nagios.hostgroup.temp')

    data = header()

    # Class groups
    for class_ in Class.select().where(True):
        members = []
        for terminal in class_.terminals:
            if terminal in terminals():
                member = str(terminal.hostname)
                members.append(member)

        name = class_.name
        full_name = class_.full_name
        rendered = render(template, name, full_name, members)

        if rendered:
            data += ''.join(['\n# ', full_name, '\n', rendered, '\n'])

    # Customer groups
    customers = {}
    # Fetch customers
    for terminal in terminals():
        if terminal.customer.id in customers:
            customers[terminal.customer.id][1].append(terminal)
        else:
            customers[terminal.customer.id] = [terminal.customer, [terminal]]
    # Fetch member terminals
    for cid in customers:
        customer = customers[cid][0]
        members = [str(terminal.hostname) for terminal in customers[cid][1]]
        name = str(customer.id)
        full_name = customer.name
        rendered = render(template, name, full_name, members)

        if rendered:
            data += ''.join(['\n# ', full_name, '\n', rendered, '\n'])

    with open(conf_path, 'w') as cfg:
        cfg.write(data)


def mkservices():
    """Generates host services"""

    lines = [header()]

    template = _template('nagios.service.temp')
    conf_path = join(
         config.monitoring['CONF_DIR'],
         config.monitoring['SERVICE_FILE_NAME'])

    for terminal in terminals():
        for service in NagiosService.applicable(terminal):
            contacts = NagiosAdmin.sieve(terminal, service)
            service = service.render(terminal, contacts, ['admins'])

            lines.append('')
            lines += list(service)
            lines.append('')

    with open(conf_path, 'w') as f:
        f.write('\n'.join(lines))


def mkservicegroups():
    """Generates service groups"""

    lines = [header()]

    template = _template('nagios.servicegroup.temp')
    conf_path = join(
         config.monitoring['CONF_DIR'],
         config.monitoring['SERVICEGROUP_FILE_NAME'])

    for service in SERVICES:
        services = []

        for terminal in filter_term(terminals(), service):
            services.append(','.join((terminal.hostname, service)))

        members = ','.join(services)
        cfg = template.format(
            servicegroup_name=service,
            alias=service.capitalize(),
            members=members)
        lines.append(cfg)

    with open(conf_path, 'w') as f:
        f.write('\n'.join(lines))


if __name__ == '__main__':
    basicConfig(level=INFO)

    options = docopt(__doc__)
    contacts = options['--contacts']
    contactgroups = options['--contactgroups']
    hosts = options['--hosts']
    hostgroups = options['--hostgroups']
    services = options['--services']
    servicegroups = options['--servicegroups']

    # Assume all options are wanted if none is selected
    all = not (contacts or contactgroups or hosts or
               hostgroups or services or servicegroups)

    if contacts or all:
        print('Generating contacts')
        mkcontacts()

    if contactgroups or all:
        print('Generating contact groups')
        mkcontactgroups()

    if hosts or all:
        print('Generating hosts')
        mkhosts()

    if hostgroups or all:
        print('Generating host groups')
        mkhostgroups()

    if services or all:
        print('Generating services')
        mkservices()

    if servicegroups or all:
        print('Generating service groups')
        mkservicegroups()

    print('Restarting nagios3 service', end='              ')
    evaluate(run('systemctl restart nagios3.service', shell=True))
