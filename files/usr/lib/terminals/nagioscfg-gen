#! /usr/bin/env python3
#
#  This file is part of the python3 package "homeinfo.terminals"
#
#  (C) 2016: HOMEINFO - Digitale Informationssysteme GmbH
#
#  Maintainer: Richard Neumann <r dot neumann at homeinfo period de>
#
#####################################################################
"""Generates Nagios3 configurations
from HOMEINFO terminals monitoring

Usage:
    nagios-config.gen [--contacts] [--contactgroups] [--hosts] \
[--hostgroups] [--services] [--servicegroups]
"""

from os.path import join, basename
from logging import INFO, basicConfig, getLogger

from docopt import docopt

from homeinfo.lib.system import run, evaluate
from homeinfo.terminals.orm import VPNUnconfiguredError, Terminal, Class, \
    NagiosAdmins
from homeinfo.terminals.config import config


__all__ = [
    'ICONS',
    'SERVICES',
    'terminals',
    'mkcontacts',
    'mkcontactgroups',
    'mkhosts',
    'mkhostgroups',
    'mkservices',
    'mkservicegroups']

ICONS = {
    'Linux': 'logos/linux.gif',
    'NT': 'logos/windows.gif'}

SERVICES = {
    # 'statistics':
    #     ('Statistics evaluation', '../graph.gif', '#'),
    'synchronization':
        ('Synchronization status', '../logrotate.png', '#'),
    'kernel':
        ('Kernel', 'logos/linux.gif', '#'),
    'resolution':
        ('Display resolution', 'monitor.png', '#'),
    'last-boot':
        ('Last boot', 'monitor.png', '#')}

logger = getLogger(basename(__file__))


def terminals():
    """Yields monitored terminals"""

    return Terminal.select().where(
            (Terminal.deleted >> None) & ~
            (Terminal.testing == 1) & ~
            (Terminal.deployed >> None))


def _template(t):
    """Opens template <t>"""

    template = join(config.monitoring['TEMPLATE_DIR'], t)

    with open(template, 'r') as f:
        return f.read()


def filter_svc(services, terminal):
    """Filters services for the provided terminal ORM"""

    # Services currently only apply tu Linux systems
    for service in services:
        if terminal.os.family == 'Linux':
            if service == 'resolution':
                if terminal.class_.name == 'ddb':
                    yield service
                else:
                    continue
            else:
                yield service


def filter_term(terminals, service):
    """Filters terminal ORMs for the provided service"""

    # Services currently only apply tu Linux systems
    for terminal in terminals:
        if terminal.os.family == 'Linux':
            if service == 'resolution':
                if terminal.class_.name == 'ddb':
                    yield terminal
                else:
                    continue
            else:
                yield terminal


def mkcontacts():
    """Generates contact configurations"""

    def render(template, admin):
        """Renders a Nagios administrator"""
        rendered = template.format(
            name=admin.name, alias=str(admin.employee),
            service_notification_period=str(admin.service_period),
            host_notification_period=str(admin.host_period),
            service_notification_options=str(admin.service_options),
            host_notification_options=str(admin.host_options),
            host_notification_commands=admin.host_command,
            email=str(admin.email))
        return rendered

    conf_path = join(
        config.monitoring['CONF_DIR'],
        config.monitoring['CONTACTS_FILE_NAME'])

    data = '# Generated by {0}\n# DO NOT EDIT THIS FILE MANUALLY!\n\n'.format(
        __file__)

    template = _template('nagios.contact.temp')

    for admin in NagiosAdmins:
        data += '{0}\n\n'.format(render(template, admin))

    with open(conf_path, 'w') as cfg:
        cfg.write(data)


def mkcontactgroups():
    """Generates contact group configurations"""

    def render(template, class_):
        """Renders a Nagios administrators for specific classes"""
        # Exclude admins
        members = [m.name for m in class_.members if not m.admin]

        if members:
            name = '_'.join([class_.name, 'admins'])
            rendered = template.format(
                name=name,
                alias=class_.full_name,
                members=','.join(members))

            return rendered
        else:
            return ''

    conf_path = join(
        config.monitoring['CONF_DIR'],
        config.monitoring['CONTACT_GROUPS_FILE_NAME'])

    template = _template('nagios.contactgroup.temp')

    data = '# Generated by {0}\n# DO NOT EDIT THIS FILE MANUALLY!\n\n'.format(
        __file__)

    for class_ in Class:
        rendered = render(template, class_)

        if rendered:
            data += '{0}\n\n'.format(rendered)

    admins = []

    for admin in NagiosAdmins.select().where(NagiosAdmins.class_ >> None):
        admins.append(admin.name)

    if admins:
        # Renders admins for all terminal classes
        rendered = template.format(
            name='admins',
            alias='Global terminal administrators',
            members=','.join(admins))
        data += '{0}\n\n'.format(rendered)

    with open(conf_path, 'w') as cfg:
        cfg.write(data)


def mkhosts():
    """Generates host configurations"""

    def render(template, terminal):
        """Renders the template with the respective data"""
        icon = ICONS.get(terminal.os.family)
        location = terminal.location

        # Get terminal's location data
        if location is not None:
            notes = repr(location)
            street = location.address.street
            house_number = location.address.house_number
            zip_code = location.address.zip_code
            city = location.address.city
            annotation = location.annotation
        else:
            notes = 'Unknown'
            street = 'Unknown'
            house_number = 'Unknown'
            zip_code = 'Unknown'
            city = 'Unknown'
            annotation = None

        try:
            ipv4addr = terminal.ipv4addr
        except VPNUnconfiguredError:
            logger.error('Terminal {0} has no VPN configuration'.format(
                terminal))
        else:
            # Render and return
            return template.format(
                tid=str(terminal.tid), cid=str(terminal.cid),
                use=terminal.class_.name, host_name=terminal.hostname,
                alias=str(terminal), address=str(ipv4addr),
                notes=notes, street=street, house_number=house_number,
                zip_code=zip_code, city=city, icon=icon)

    conf_path = join(
        config.monitoring['CONF_DIR'],
        config.monitoring['HOSTS_FILE_NAME'])

    template = _template('nagios.host.temp')

    data = '# Generated by {0}\n# DO NOT EDIT THIS FILE MANUALLY!\n\n'.format(
        __file__)

    for terminal in terminals():
        data += '\n# {0}\n{1}\n'.format(terminal, render(template, terminal))

    with open(conf_path, 'w') as cfg:
        cfg.write(data)


def mkhostgroups():
    """Generates hostgroup configurations"""

    def render(template, name, full_name, memebers):
        """Renders host groups"""
        if members:
            rendered = template.format(
                name=name,
                alias=full_name,
                members=','.join(memebers))

            return rendered
        else:
            return ''

    conf_path = join(
        config.monitoring['CONF_DIR'],
        config.monitoring['GROUPS_FILE_NAME'])

    template = _template('nagios.hostgroup.temp')

    data = '\n'.join([' '.join(['# Generated by', __file__]),
                      '# DO NOT EDIT THIS FILE MANUALLY!\n\n'])

    # Class groups
    for class_ in Class.select().where(True):
        members = []
        for terminal in class_.terminals:
            if terminal in terminals():
                member = str(terminal.hostname)
                members.append(member)

        name = class_.name
        full_name = class_.full_name
        rendered = render(template, name, full_name, members)

        if rendered:
            data += ''.join(['\n# ', full_name, '\n', rendered, '\n'])

    # Customer groups
    customers = {}
    # Fetch customers
    for terminal in terminals():
        if terminal.customer.id in customers:
            customers[terminal.customer.id][1].append(terminal)
        else:
            customers[terminal.customer.id] = [terminal.customer, [terminal]]
    # Fetch member terminals
    for cid in customers:
        customer = customers[cid][0]
        members = [str(terminal.hostname) for terminal in customers[cid][1]]
        name = str(customer.id)
        full_name = customer.name
        rendered = render(template, name, full_name, members)

        if rendered:
            data += ''.join(['\n# ', full_name, '\n', rendered, '\n'])

    with open(conf_path, 'w') as cfg:
        cfg.write(data)


def mkservices():
    """Generates host services"""

    header = '\n'.join([' '.join(['# Generated by', __file__]),
                        '# DO NOT EDIT THIS FILE MANUALLY!\n'])
    lines = [header]

    template = _template('nagios.service.temp')
    conf_path = join(
         config.monitoring['CONF_DIR'],
         config.monitoring['SERVICE_FILE_NAME'])

    for terminal in terminals():
        for service in filter_svc(SERVICES, terminal):
            notes, icon_image, action_url = SERVICES[service]
            check_command = 'check_{0}!{1}!{2}'.format(
                service, terminal.tid, terminal.customer.id)
            contact_groups = ['admins']

            if terminal.class_.name == 'ddb':
                contact_groups.append('ddb_admins')

            lines.append(template.format(
                host_name=terminal.hostname,
                service_description=service,
                check_command=check_command,
                max_check_attempts=5,
                check_interval=15,
                retry_interval=5,
                check_period='24x7',
                notification_interval=0,  # Only notify once
                notification_period='24x7',
                contact_groups=','.join(contact_groups),
                notes=notes,
                icon_image=icon_image))

    with open(conf_path, 'w') as f:
        f.write('\n'.join(lines))


def mkservicegroups():
    """Generates service groups"""

    header = '\n'.join([' '.join(['# Generated by', __file__]),
                        '# DO NOT EDIT THIS FILE MANUALLY!\n'])
    lines = [header]

    template = _template('nagios.servicegroup.temp')
    conf_path = join(
         config.monitoring['CONF_DIR'],
         config.monitoring['SERVICEGROUP_FILE_NAME'])

    for service in SERVICES:
        services = []

        for terminal in filter_term(terminals(), service):
            services.append(','.join((terminal.hostname, service)))

        members = ','.join(services)
        cfg = template.format(
            servicegroup_name=service,
            alias=service.capitalize(),
            members=members)
        lines.append(cfg)

    with open(conf_path, 'w') as f:
        f.write('\n'.join(lines))


if __name__ == '__main__':
    basicConfig(level=INFO)

    options = docopt(__doc__)
    contacts = options['--contacts']
    contactgroups = options['--contactgroups']
    hosts = options['--hosts']
    hostgroups = options['--hostgroups']
    services = options['--services']
    servicegroups = options['--servicegroups']

    # Assume all options are wanted if none is selected
    all = not (contacts or contactgroups or hosts or
               hostgroups or services or servicegroups)

    if contacts or all:
        print('Generating contacts')
        mkcontacts()

    if contactgroups or all:
        print('Generating contact groups')
        mkcontactgroups()

    if hosts or all:
        print('Generating hosts')
        mkhosts()

    if hostgroups or all:
        print('Generating host groups')
        mkhostgroups()

    if services or all:
        print('Generating services')
        mkservices()

    if servicegroups or all:
        print('Generating service groups')
        mkservicegroups()

    print('Restarting nagios3 service', end='              ')
    evaluate(run('systemctl restart nagios3.service', shell=True))
